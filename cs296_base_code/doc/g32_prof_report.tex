\documentclass[11pt]{article}
\title{\textbf{CS 296: Lab 7}}
\author{Siddhartha Dutta \\ 120040005 \and Gangadhar KV \\ 120050078 \and Sai Krishna Kethan \\ 120050065}
\date{March 1, 2014}
\usepackage{graphicx}
\begin{document}

\maketitle

\section{Timing}
\subsection{Analyzing results of Lab 5}

\begin{figure}[ht!]
\centering
\includegraphics[width=90mm]{g32_lab09_plot02.png}
\caption{Avg. Step Time vs Iteration Values}
\label{overflow}
\end{figure}

In the above graph, we observe that the average step time in the beginning is quite high. As the number of iterations increases, the average step time keeps decreasing. There is a sharp fall after around 30 iterations. But after 140 iterations, the step time increases a bit till around 150 and then levels off. The above graph shows data for 300 iterations. 

This can be explained if we realize that in a given loop greater time is spent to resolve collisions. The occassional spikes in the graph show that collision solver is called only when needed.

In every loop "Step" in B2World in called. A solver is used in collision time, velocity time and position time. Box2D also uses a constraint solver for solving constraints. The constraint solver solves all the constraints in the simulation, one at a time. Altough single constraint can be solved perfectly, when we solve one constraint, we slightly disrupt other constraints. Therefore to get a good solution, we need to iterate over all constraints a number of times. Thus, multiple iterations for position and velocity are needed.

In the beginning, there are a huge number of collisions involving the dominos and balls hitting each other. But as time passes most things come to a halt and collisions reduce. Hence, the plateau in the graph.

\begin{figure}[ht!]
\centering
\includegraphics[width=90mm]{g32_lab09_plot01.png}
\caption{Total loop time}
\label{overflow}
\end{figure}

This graph reiterates the observations made earlier. After around 200 iterations, the total loop time becomes completely linear to the number of iterations. This is in concurrence with the fact that the average step time becomes constant.

\begin{figure}[ht!]
\centering
\includegraphics[width=90mm]{g32_lab09_plot03.png}
\caption{Avg. Step Time vs Iteration Values with error bars}
\label{overflow}
\end{figure}

The above plot represents average step time and y-error bars. As can be clearly observed, the difference between the maximum and minimum values is very large. The values are taken within 15 system iterations(very close times for processing). The differences can be attributed to system processes. The error range is intitially a bit high when step times are high but becomes constant as the step time levels off.


\subsection{Time vs gettimeofday()}
Time writes to standard error giving various statistics regarding the running time of the program. These statistics consist of 
\begin{enumerate}
\item the elapsed real time between invocation and termination, 
% \item the user CPU time (the sum of the tms_utime and tms_cutime values in a struct tms), and 
% \item the system CPU time (the sum of the tms_stime and tms_cstime values in a struct tms).
\end{enumerate}
Time command measures the whole program execution time, including the time it takes to load the binary and all its libraries. It also includes the time it takes to clean up everything once the program is finished.

On the other hand, gettimeofday can only work inside the program, that is after it has finished loading (for the initial measurement) and before it is cleaned up (for the final measurement). It gives the exact time required to execute the function.

The function gettimeofday has higher resolution than time: time can return only in seconds while gettimeofday() returns in microseconds.

\subsection{System under heavy loading}
While running CPU heavy processes, the time increases since smaller processing time is devoted to our process. I tried this by making several codes run in different terminals.

On the other hand while running RAM intensive processes, it waits and tries to kill other processes. Since the processor may be idle all this while, there's no significant change in time. 

\section{Profiling}
\subsection{Introduction}

Profiling is a form of dynamic program analysis that measures, the space (memory) or time complexity of a program, the usage of particular instructions, or frequency and duration of function calls. The most common use of profiling information is to aid program optimization.

\subsection{Optimization}
Turning on optimization flags makes the compiler attempt to improve the performance and/or code size at the expense of compilation time and possibly the ability to debug the program. The compiler performs optimization based on the knowledge it has of the program. Optimization levels -O2 and above, in particular, enable unit-at-a-time mode, which allows the compiler to consider information gained from later functions in the file when compiling a function. Compiling multiple files at once to a single output file in unit-at-a-time mode allows the compiler to use information gained from all of the files when compiling each of them. An example of optimization is inlining the functions.

For what follows, the profiler was run over 1000 iterations.

\subsection{Release Build}


\begin{figure}[ht!]
\centering
\includegraphics[width=150mm]{g32_release_prof.png}
\caption{Call graph for Release}
\label{overflow}
\end{figure}

\begin{figure}[ht!]
\centering
\includegraphics[width=150mm]{release.png}
\caption{Call graph for Release}
\label{overflow}
\end{figure}

The release build is faster than the debug build since it uses optimization. Also it eliminates debugging information since it meant for the end-user. We used the O3 flag for compilation and used cmake -DCMAKE\_BUILD\_TYPE=Release for building.


\subsection{Debug Build}

Following the release mode, the debug mode was tried out. This was done by eliminating the -O3 flag during compilation and using cmake -DCMAKE\_BUILD\_TYPE=Debug  for building.

\begin{figure}[ht!]
\centering
\includegraphics[width=150mm]{g32_debug_prof.png}
\caption{Call graph for Release}
\label{overflow}
\end{figure}

\begin{figure}[ht!]
\centering
\includegraphics[width=150mm]{debug.png}
\caption{Call graph for debug}
\label{overflow}
\end{figure}

\end{document}
